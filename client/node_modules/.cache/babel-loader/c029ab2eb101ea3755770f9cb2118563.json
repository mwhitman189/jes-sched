{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = getStyledEvents;\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _sortBy = _interopRequireDefault(require(\"lodash/sortBy\"));\n\nvar Event =\n/*#__PURE__*/\nfunction () {\n  function Event(data, _ref) {\n    var accessors = _ref.accessors,\n        slotMetrics = _ref.slotMetrics;\n\n    var _slotMetrics$getRange = slotMetrics.getRange(accessors.start(data), accessors.end(data)),\n        start = _slotMetrics$getRange.start,\n        startDate = _slotMetrics$getRange.startDate,\n        end = _slotMetrics$getRange.end,\n        endDate = _slotMetrics$getRange.endDate,\n        top = _slotMetrics$getRange.top,\n        height = _slotMetrics$getRange.height;\n\n    this.start = start;\n    this.end = end;\n    this.startMs = +startDate;\n    this.endMs = +endDate;\n    this.top = top;\n    this.height = height;\n    this.data = data;\n  }\n  /**\n   * The event's width without any overlap.\n   */\n\n\n  (0, _createClass2.default)(Event, [{\n    key: \"_width\",\n    get: function get() {\n      // The container event's width is determined by the maximum number of\n      // events in any of its rows.\n      if (this.rows) {\n        var columns = this.rows.reduce(function (max, row) {\n          return Math.max(max, row.leaves.length + 1);\n        }, // add itself\n        0) + 1; // add the container\n\n        return 100 / columns;\n      }\n\n      var availableWidth = 100 - this.container._width; // The row event's width is the space left by the container, divided\n      // among itself and its leaves.\n\n      if (this.leaves) {\n        return availableWidth / (this.leaves.length + 1);\n      } // The leaf event's width is determined by its row's width\n\n\n      return this.row._width;\n    }\n    /**\n     * The event's calculated width, possibly with extra width added for\n     * overlapping effect.\n     */\n\n  }, {\n    key: \"width\",\n    get: function get() {\n      var noOverlap = this._width;\n      var overlap = Math.min(100, this._width * 1.7); // Containers can always grow.\n\n      if (this.rows) {\n        return overlap;\n      } // Rows can grow if they have leaves.\n\n\n      if (this.leaves) {\n        return this.leaves.length > 0 ? overlap : noOverlap;\n      } // Leaves can grow unless they're the last item in a row.\n\n\n      var leaves = this.row.leaves;\n      var index = leaves.indexOf(this);\n      return index === leaves.length - 1 ? noOverlap : overlap;\n    }\n  }, {\n    key: \"xOffset\",\n    get: function get() {\n      // Containers have no offset.\n      if (this.rows) return 0; // Rows always start where their container ends.\n\n      if (this.leaves) return this.container._width; // Leaves are spread out evenly on the space left by its row.\n\n      var _this$row = this.row,\n          leaves = _this$row.leaves,\n          xOffset = _this$row.xOffset,\n          _width = _this$row._width;\n      var index = leaves.indexOf(this) + 1;\n      return xOffset + index * _width;\n    }\n  }]);\n  return Event;\n}();\n/**\n * Return true if event a and b is considered to be on the same row.\n */\n\n\nfunction onSameRow(a, b, minimumStartDifference) {\n  return (// Occupies the same start slot.\n    Math.abs(b.start - a.start) < minimumStartDifference || // A's start slot overlaps with b's end slot.\n    b.start > a.start && b.start < a.end\n  );\n}\n\nfunction sortByRender(events) {\n  var sortedByTime = (0, _sortBy.default)(events, ['startMs', function (e) {\n    return -e.endMs;\n  }]);\n  var sorted = [];\n\n  while (sortedByTime.length > 0) {\n    var event = sortedByTime.shift();\n    sorted.push(event);\n\n    for (var i = 0; i < sortedByTime.length; i++) {\n      var test = sortedByTime[i]; // Still inside this event, look for next.\n\n      if (event.endMs > test.startMs) continue; // We've found the first event of the next event group.\n      // If that event is not right next to our current event, we have to\n      // move it here.\n\n      if (i > 0) {\n        var _event = sortedByTime.splice(i, 1)[0];\n        sorted.push(_event);\n      } // We've already found the next event group, so stop looking.\n\n\n      break;\n    }\n  }\n\n  return sorted;\n}\n\nfunction getStyledEvents(_ref2) {\n  var events = _ref2.events,\n      minimumStartDifference = _ref2.minimumStartDifference,\n      slotMetrics = _ref2.slotMetrics,\n      accessors = _ref2.accessors; // Create proxy events and order them so that we don't have\n  // to fiddle with z-indexes.\n\n  var proxies = events.map(function (event) {\n    return new Event(event, {\n      slotMetrics: slotMetrics,\n      accessors: accessors\n    });\n  });\n  var eventsInRenderOrder = sortByRender(proxies); // Group overlapping events, while keeping order.\n  // Every event is always one of: container, row or leaf.\n  // Containers can contain rows, and rows can contain leaves.\n\n  var containerEvents = [];\n\n  var _loop = function _loop(i) {\n    var event = eventsInRenderOrder[i]; // Check if this event can go into a container event.\n\n    var container = containerEvents.find(function (c) {\n      return c.end > event.start || Math.abs(event.start - c.start) < minimumStartDifference;\n    }); // Couldn't find a container — that means this event is a container.\n\n    if (!container) {\n      event.rows = [];\n      containerEvents.push(event);\n      return \"continue\";\n    } // Found a container for the event.\n\n\n    event.container = container; // Check if the event can be placed in an existing row.\n    // Start looking from behind.\n\n    var row = null;\n\n    for (var j = container.rows.length - 1; !row && j >= 0; j--) {\n      if (onSameRow(container.rows[j], event, minimumStartDifference)) {\n        row = container.rows[j];\n      }\n    }\n\n    if (row) {\n      // Found a row, so add it.\n      row.leaves.push(event);\n      event.row = row;\n    } else {\n      // Couldn't find a row – that means this event is a row.\n      event.leaves = [];\n      container.rows.push(event);\n    }\n  };\n\n  for (var i = 0; i < eventsInRenderOrder.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === \"continue\") continue;\n  } // Return the original events, along with their styles.\n\n\n  return eventsInRenderOrder.map(function (event) {\n    return {\n      event: event.data,\n      style: {\n        top: event.top,\n        height: event.height,\n        width: event.width,\n        xOffset: Math.max(0, event.xOffset)\n      }\n    };\n  });\n}\n\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/home/miles/Desktop/jes-sched/client/node_modules/react-big-calendar/lib/utils/layout-algorithms/overlap.js"],"names":["_interopRequireDefault","require","exports","__esModule","default","getStyledEvents","_createClass2","_sortBy","Event","data","_ref","accessors","slotMetrics","_slotMetrics$getRange","getRange","start","end","startDate","endDate","top","height","startMs","endMs","key","get","rows","columns","reduce","max","row","Math","leaves","length","availableWidth","container","_width","noOverlap","overlap","min","index","indexOf","_this$row","xOffset","onSameRow","a","b","minimumStartDifference","abs","sortByRender","events","sortedByTime","e","sorted","event","shift","push","i","test","_event","splice","_ref2","proxies","map","eventsInRenderOrder","containerEvents","_loop","find","c","j","_ret","style","width","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = getStyledEvents;\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _sortBy = _interopRequireDefault(require(\"lodash/sortBy\"));\n\nvar Event =\n/*#__PURE__*/\nfunction () {\n  function Event(data, _ref) {\n    var accessors = _ref.accessors,\n        slotMetrics = _ref.slotMetrics;\n\n    var _slotMetrics$getRange = slotMetrics.getRange(accessors.start(data), accessors.end(data)),\n        start = _slotMetrics$getRange.start,\n        startDate = _slotMetrics$getRange.startDate,\n        end = _slotMetrics$getRange.end,\n        endDate = _slotMetrics$getRange.endDate,\n        top = _slotMetrics$getRange.top,\n        height = _slotMetrics$getRange.height;\n\n    this.start = start;\n    this.end = end;\n    this.startMs = +startDate;\n    this.endMs = +endDate;\n    this.top = top;\n    this.height = height;\n    this.data = data;\n  }\n  /**\n   * The event's width without any overlap.\n   */\n\n\n  (0, _createClass2.default)(Event, [{\n    key: \"_width\",\n    get: function get() {\n      // The container event's width is determined by the maximum number of\n      // events in any of its rows.\n      if (this.rows) {\n        var columns = this.rows.reduce(function (max, row) {\n          return Math.max(max, row.leaves.length + 1);\n        }, // add itself\n        0) + 1; // add the container\n\n        return 100 / columns;\n      }\n\n      var availableWidth = 100 - this.container._width; // The row event's width is the space left by the container, divided\n      // among itself and its leaves.\n\n      if (this.leaves) {\n        return availableWidth / (this.leaves.length + 1);\n      } // The leaf event's width is determined by its row's width\n\n\n      return this.row._width;\n    }\n    /**\n     * The event's calculated width, possibly with extra width added for\n     * overlapping effect.\n     */\n\n  }, {\n    key: \"width\",\n    get: function get() {\n      var noOverlap = this._width;\n      var overlap = Math.min(100, this._width * 1.7); // Containers can always grow.\n\n      if (this.rows) {\n        return overlap;\n      } // Rows can grow if they have leaves.\n\n\n      if (this.leaves) {\n        return this.leaves.length > 0 ? overlap : noOverlap;\n      } // Leaves can grow unless they're the last item in a row.\n\n\n      var leaves = this.row.leaves;\n      var index = leaves.indexOf(this);\n      return index === leaves.length - 1 ? noOverlap : overlap;\n    }\n  }, {\n    key: \"xOffset\",\n    get: function get() {\n      // Containers have no offset.\n      if (this.rows) return 0; // Rows always start where their container ends.\n\n      if (this.leaves) return this.container._width; // Leaves are spread out evenly on the space left by its row.\n\n      var _this$row = this.row,\n          leaves = _this$row.leaves,\n          xOffset = _this$row.xOffset,\n          _width = _this$row._width;\n      var index = leaves.indexOf(this) + 1;\n      return xOffset + index * _width;\n    }\n  }]);\n  return Event;\n}();\n/**\n * Return true if event a and b is considered to be on the same row.\n */\n\n\nfunction onSameRow(a, b, minimumStartDifference) {\n  return (// Occupies the same start slot.\n    Math.abs(b.start - a.start) < minimumStartDifference || // A's start slot overlaps with b's end slot.\n    b.start > a.start && b.start < a.end\n  );\n}\n\nfunction sortByRender(events) {\n  var sortedByTime = (0, _sortBy.default)(events, ['startMs', function (e) {\n    return -e.endMs;\n  }]);\n  var sorted = [];\n\n  while (sortedByTime.length > 0) {\n    var event = sortedByTime.shift();\n    sorted.push(event);\n\n    for (var i = 0; i < sortedByTime.length; i++) {\n      var test = sortedByTime[i]; // Still inside this event, look for next.\n\n      if (event.endMs > test.startMs) continue; // We've found the first event of the next event group.\n      // If that event is not right next to our current event, we have to\n      // move it here.\n\n      if (i > 0) {\n        var _event = sortedByTime.splice(i, 1)[0];\n        sorted.push(_event);\n      } // We've already found the next event group, so stop looking.\n\n\n      break;\n    }\n  }\n\n  return sorted;\n}\n\nfunction getStyledEvents(_ref2) {\n  var events = _ref2.events,\n      minimumStartDifference = _ref2.minimumStartDifference,\n      slotMetrics = _ref2.slotMetrics,\n      accessors = _ref2.accessors;\n  // Create proxy events and order them so that we don't have\n  // to fiddle with z-indexes.\n  var proxies = events.map(function (event) {\n    return new Event(event, {\n      slotMetrics: slotMetrics,\n      accessors: accessors\n    });\n  });\n  var eventsInRenderOrder = sortByRender(proxies); // Group overlapping events, while keeping order.\n  // Every event is always one of: container, row or leaf.\n  // Containers can contain rows, and rows can contain leaves.\n\n  var containerEvents = [];\n\n  var _loop = function _loop(i) {\n    var event = eventsInRenderOrder[i]; // Check if this event can go into a container event.\n\n    var container = containerEvents.find(function (c) {\n      return c.end > event.start || Math.abs(event.start - c.start) < minimumStartDifference;\n    }); // Couldn't find a container — that means this event is a container.\n\n    if (!container) {\n      event.rows = [];\n      containerEvents.push(event);\n      return \"continue\";\n    } // Found a container for the event.\n\n\n    event.container = container; // Check if the event can be placed in an existing row.\n    // Start looking from behind.\n\n    var row = null;\n\n    for (var j = container.rows.length - 1; !row && j >= 0; j--) {\n      if (onSameRow(container.rows[j], event, minimumStartDifference)) {\n        row = container.rows[j];\n      }\n    }\n\n    if (row) {\n      // Found a row, so add it.\n      row.leaves.push(event);\n      event.row = row;\n    } else {\n      // Couldn't find a row – that means this event is a row.\n      event.leaves = [];\n      container.rows.push(event);\n    }\n  };\n\n  for (var i = 0; i < eventsInRenderOrder.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === \"continue\") continue;\n  } // Return the original events, along with their styles.\n\n\n  return eventsInRenderOrder.map(function (event) {\n    return {\n      event: event.data,\n      style: {\n        top: event.top,\n        height: event.height,\n        width: event.width,\n        xOffset: Math.max(0, event.xOffset)\n      }\n    };\n  });\n}\n\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}