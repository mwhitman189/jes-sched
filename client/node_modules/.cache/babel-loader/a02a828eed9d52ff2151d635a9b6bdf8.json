{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = _default;\n\nvar _overlap = _interopRequireDefault(require(\"./overlap\"));\n\nfunction getMaxIdxDFS(node, maxIdx, visited) {\n  for (var i = 0; i < node.friends.length; ++i) {\n    if (visited.indexOf(node.friends[i]) > -1) continue;\n    maxIdx = maxIdx > node.friends[i].idx ? maxIdx : node.friends[i].idx; // TODO : trace it by not object but kinda index or something for performance\n\n    visited.push(node.friends[i]);\n    var newIdx = getMaxIdxDFS(node.friends[i], maxIdx, visited);\n    maxIdx = maxIdx > newIdx ? maxIdx : newIdx;\n  }\n\n  return maxIdx;\n}\n\nfunction _default(_ref) {\n  var events = _ref.events,\n      minimumStartDifference = _ref.minimumStartDifference,\n      slotMetrics = _ref.slotMetrics,\n      accessors = _ref.accessors;\n  var styledEvents = (0, _overlap.default)({\n    events: events,\n    minimumStartDifference: minimumStartDifference,\n    slotMetrics: slotMetrics,\n    accessors: accessors\n  });\n  styledEvents.sort(function (a, b) {\n    a = a.style;\n    b = b.style;\n    if (a.top !== b.top) return a.top > b.top ? 1 : -1;else return a.top + a.height < b.top + b.height ? 1 : -1;\n  });\n\n  for (var i = 0; i < styledEvents.length; ++i) {\n    styledEvents[i].friends = [];\n    delete styledEvents[i].style.left;\n    delete styledEvents[i].style.left;\n    delete styledEvents[i].idx;\n    delete styledEvents[i].size;\n  }\n\n  for (var _i = 0; _i < styledEvents.length - 1; ++_i) {\n    var se1 = styledEvents[_i];\n    var y1 = se1.style.top;\n    var y2 = se1.style.top + se1.style.height;\n\n    for (var j = _i + 1; j < styledEvents.length; ++j) {\n      var se2 = styledEvents[j];\n      var y3 = se2.style.top;\n      var y4 = se2.style.top + se2.style.height; // be friends when overlapped\n\n      if (y3 <= y1 && y1 < y4 || y1 <= y3 && y3 < y2) {\n        // TODO : hashmap would be effective for performance\n        se1.friends.push(se2);\n        se2.friends.push(se1);\n      }\n    }\n  }\n\n  for (var _i2 = 0; _i2 < styledEvents.length; ++_i2) {\n    var se = styledEvents[_i2];\n    var bitmap = [];\n\n    for (var _j = 0; _j < 100; ++_j) {\n      bitmap.push(1);\n    } // 1 means available\n\n\n    for (var _j2 = 0; _j2 < se.friends.length; ++_j2) {\n      if (se.friends[_j2].idx !== undefined) bitmap[se.friends[_j2].idx] = 0;\n    } // 0 means reserved\n\n\n    se.idx = bitmap.indexOf(1);\n  }\n\n  for (var _i3 = 0; _i3 < styledEvents.length; ++_i3) {\n    var size = 0;\n    if (styledEvents[_i3].size) continue;\n    var allFriends = [];\n    var maxIdx = getMaxIdxDFS(styledEvents[_i3], 0, allFriends);\n    size = 100 / (maxIdx + 1);\n    styledEvents[_i3].size = size;\n\n    for (var _j3 = 0; _j3 < allFriends.length; ++_j3) {\n      allFriends[_j3].size = size;\n    }\n  }\n\n  for (var _i4 = 0; _i4 < styledEvents.length; ++_i4) {\n    var e = styledEvents[_i4];\n    e.style.left = e.idx * e.size; // stretch to maximum\n\n    var _maxIdx = 0;\n\n    for (var _j4 = 0; _j4 < e.friends.length; ++_j4) {\n      var idx = e.friends[_j4];\n      _maxIdx = _maxIdx > idx ? _maxIdx : idx;\n    }\n\n    if (_maxIdx <= e.idx) e.size = 100 - e.idx * e.size; // padding between events\n    // for this feature, `width` is not percentage based unit anymore\n    // it will be used with calc()\n\n    var padding = e.idx === 0 ? 0 : 3;\n    e.style.width = \"calc(\" + e.size + \"% - \" + padding + \"px)\";\n    e.style.height = \"calc(\" + e.style.height + \"% - 2px)\";\n    e.style.xOffset = \"calc(\" + e.style.left + \"% + \" + padding + \"px)\";\n  }\n\n  return styledEvents;\n}\n\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/home/miles/webdev/jes-sched/client/node_modules/react-big-calendar/lib/utils/layout-algorithms/no-overlap.js"],"names":["_interopRequireDefault","require","exports","__esModule","default","_default","_overlap","getMaxIdxDFS","node","maxIdx","visited","i","friends","length","indexOf","idx","push","newIdx","_ref","events","minimumStartDifference","slotMetrics","accessors","styledEvents","sort","a","b","style","top","height","left","size","_i","se1","y1","y2","j","se2","y3","y4","_i2","se","bitmap","_j","_j2","undefined","_i3","allFriends","_j3","_i4","e","_maxIdx","_j4","padding","width","xOffset","module"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkBC,QAAlB;;AAEA,IAAIC,QAAQ,GAAGN,sBAAsB,CAACC,OAAO,CAAC,WAAD,CAAR,CAArC;;AAEA,SAASM,YAAT,CAAsBC,IAAtB,EAA4BC,MAA5B,EAAoCC,OAApC,EAA6C;AAC3C,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACI,OAAL,CAAaC,MAAjC,EAAyC,EAAEF,CAA3C,EAA8C;AAC5C,QAAID,OAAO,CAACI,OAAR,CAAgBN,IAAI,CAACI,OAAL,CAAaD,CAAb,CAAhB,IAAmC,CAAC,CAAxC,EAA2C;AAC3CF,IAAAA,MAAM,GAAGA,MAAM,GAAGD,IAAI,CAACI,OAAL,CAAaD,CAAb,EAAgBI,GAAzB,GAA+BN,MAA/B,GAAwCD,IAAI,CAACI,OAAL,CAAaD,CAAb,EAAgBI,GAAjE,CAF4C,CAE0B;;AAEtEL,IAAAA,OAAO,CAACM,IAAR,CAAaR,IAAI,CAACI,OAAL,CAAaD,CAAb,CAAb;AACA,QAAIM,MAAM,GAAGV,YAAY,CAACC,IAAI,CAACI,OAAL,CAAaD,CAAb,CAAD,EAAkBF,MAAlB,EAA0BC,OAA1B,CAAzB;AACAD,IAAAA,MAAM,GAAGA,MAAM,GAAGQ,MAAT,GAAkBR,MAAlB,GAA2BQ,MAApC;AACD;;AAED,SAAOR,MAAP;AACD;;AAED,SAASJ,QAAT,CAAkBa,IAAlB,EAAwB;AACtB,MAAIC,MAAM,GAAGD,IAAI,CAACC,MAAlB;AAAA,MACIC,sBAAsB,GAAGF,IAAI,CAACE,sBADlC;AAAA,MAEIC,WAAW,GAAGH,IAAI,CAACG,WAFvB;AAAA,MAGIC,SAAS,GAAGJ,IAAI,CAACI,SAHrB;AAIA,MAAIC,YAAY,GAAG,CAAC,GAAGjB,QAAQ,CAACF,OAAb,EAAsB;AACvCe,IAAAA,MAAM,EAAEA,MAD+B;AAEvCC,IAAAA,sBAAsB,EAAEA,sBAFe;AAGvCC,IAAAA,WAAW,EAAEA,WAH0B;AAIvCC,IAAAA,SAAS,EAAEA;AAJ4B,GAAtB,CAAnB;AAMAC,EAAAA,YAAY,CAACC,IAAb,CAAkB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCD,IAAAA,CAAC,GAAGA,CAAC,CAACE,KAAN;AACAD,IAAAA,CAAC,GAAGA,CAAC,CAACC,KAAN;AACA,QAAIF,CAAC,CAACG,GAAF,KAAUF,CAAC,CAACE,GAAhB,EAAqB,OAAOH,CAAC,CAACG,GAAF,GAAQF,CAAC,CAACE,GAAV,GAAgB,CAAhB,GAAoB,CAAC,CAA5B,CAArB,KAAwD,OAAOH,CAAC,CAACG,GAAF,GAAQH,CAAC,CAACI,MAAV,GAAmBH,CAAC,CAACE,GAAF,GAAQF,CAAC,CAACG,MAA7B,GAAsC,CAAtC,GAA0C,CAAC,CAAlD;AACzD,GAJD;;AAMA,OAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,YAAY,CAACV,MAAjC,EAAyC,EAAEF,CAA3C,EAA8C;AAC5CY,IAAAA,YAAY,CAACZ,CAAD,CAAZ,CAAgBC,OAAhB,GAA0B,EAA1B;AACA,WAAOW,YAAY,CAACZ,CAAD,CAAZ,CAAgBgB,KAAhB,CAAsBG,IAA7B;AACA,WAAOP,YAAY,CAACZ,CAAD,CAAZ,CAAgBgB,KAAhB,CAAsBG,IAA7B;AACA,WAAOP,YAAY,CAACZ,CAAD,CAAZ,CAAgBI,GAAvB;AACA,WAAOQ,YAAY,CAACZ,CAAD,CAAZ,CAAgBoB,IAAvB;AACD;;AAED,OAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGT,YAAY,CAACV,MAAb,GAAsB,CAA5C,EAA+C,EAAEmB,EAAjD,EAAqD;AACnD,QAAIC,GAAG,GAAGV,YAAY,CAACS,EAAD,CAAtB;AACA,QAAIE,EAAE,GAAGD,GAAG,CAACN,KAAJ,CAAUC,GAAnB;AACA,QAAIO,EAAE,GAAGF,GAAG,CAACN,KAAJ,CAAUC,GAAV,GAAgBK,GAAG,CAACN,KAAJ,CAAUE,MAAnC;;AAEA,SAAK,IAAIO,CAAC,GAAGJ,EAAE,GAAG,CAAlB,EAAqBI,CAAC,GAAGb,YAAY,CAACV,MAAtC,EAA8C,EAAEuB,CAAhD,EAAmD;AACjD,UAAIC,GAAG,GAAGd,YAAY,CAACa,CAAD,CAAtB;AACA,UAAIE,EAAE,GAAGD,GAAG,CAACV,KAAJ,CAAUC,GAAnB;AACA,UAAIW,EAAE,GAAGF,GAAG,CAACV,KAAJ,CAAUC,GAAV,GAAgBS,GAAG,CAACV,KAAJ,CAAUE,MAAnC,CAHiD,CAGN;;AAE3C,UAAIS,EAAE,IAAIJ,EAAN,IAAYA,EAAE,GAAGK,EAAjB,IAAuBL,EAAE,IAAII,EAAN,IAAYA,EAAE,GAAGH,EAA5C,EAAgD;AAC9C;AACAF,QAAAA,GAAG,CAACrB,OAAJ,CAAYI,IAAZ,CAAiBqB,GAAjB;AACAA,QAAAA,GAAG,CAACzB,OAAJ,CAAYI,IAAZ,CAAiBiB,GAAjB;AACD;AACF;AACF;;AAED,OAAK,IAAIO,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGjB,YAAY,CAACV,MAArC,EAA6C,EAAE2B,GAA/C,EAAoD;AAClD,QAAIC,EAAE,GAAGlB,YAAY,CAACiB,GAAD,CAArB;AACA,QAAIE,MAAM,GAAG,EAAb;;AAEA,SAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,GAAtB,EAA2B,EAAEA,EAA7B,EAAiC;AAC/BD,MAAAA,MAAM,CAAC1B,IAAP,CAAY,CAAZ;AACD,KANiD,CAMhD;;;AAGF,SAAK,IAAI4B,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,EAAE,CAAC7B,OAAH,CAAWC,MAAnC,EAA2C,EAAE+B,GAA7C,EAAkD;AAChD,UAAIH,EAAE,CAAC7B,OAAH,CAAWgC,GAAX,EAAgB7B,GAAhB,KAAwB8B,SAA5B,EAAuCH,MAAM,CAACD,EAAE,CAAC7B,OAAH,CAAWgC,GAAX,EAAgB7B,GAAjB,CAAN,GAA8B,CAA9B;AACxC,KAXiD,CAWhD;;;AAGF0B,IAAAA,EAAE,CAAC1B,GAAH,GAAS2B,MAAM,CAAC5B,OAAP,CAAe,CAAf,CAAT;AACD;;AAED,OAAK,IAAIgC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGvB,YAAY,CAACV,MAArC,EAA6C,EAAEiC,GAA/C,EAAoD;AAClD,QAAIf,IAAI,GAAG,CAAX;AACA,QAAIR,YAAY,CAACuB,GAAD,CAAZ,CAAkBf,IAAtB,EAA4B;AAC5B,QAAIgB,UAAU,GAAG,EAAjB;AACA,QAAItC,MAAM,GAAGF,YAAY,CAACgB,YAAY,CAACuB,GAAD,CAAb,EAAoB,CAApB,EAAuBC,UAAvB,CAAzB;AACAhB,IAAAA,IAAI,GAAG,OAAOtB,MAAM,GAAG,CAAhB,CAAP;AACAc,IAAAA,YAAY,CAACuB,GAAD,CAAZ,CAAkBf,IAAlB,GAAyBA,IAAzB;;AAEA,SAAK,IAAIiB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,UAAU,CAAClC,MAAnC,EAA2C,EAAEmC,GAA7C,EAAkD;AAChDD,MAAAA,UAAU,CAACC,GAAD,CAAV,CAAgBjB,IAAhB,GAAuBA,IAAvB;AACD;AACF;;AAED,OAAK,IAAIkB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG1B,YAAY,CAACV,MAArC,EAA6C,EAAEoC,GAA/C,EAAoD;AAClD,QAAIC,CAAC,GAAG3B,YAAY,CAAC0B,GAAD,CAApB;AACAC,IAAAA,CAAC,CAACvB,KAAF,CAAQG,IAAR,GAAeoB,CAAC,CAACnC,GAAF,GAAQmC,CAAC,CAACnB,IAAzB,CAFkD,CAEnB;;AAE/B,QAAIoB,OAAO,GAAG,CAAd;;AAEA,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,CAAC,CAACtC,OAAF,CAAUC,MAAlC,EAA0C,EAAEuC,GAA5C,EAAiD;AAC/C,UAAIrC,GAAG,GAAGmC,CAAC,CAACtC,OAAF,CAAUwC,GAAV,CAAV;AACAD,MAAAA,OAAO,GAAGA,OAAO,GAAGpC,GAAV,GAAgBoC,OAAhB,GAA0BpC,GAApC;AACD;;AAED,QAAIoC,OAAO,IAAID,CAAC,CAACnC,GAAjB,EAAsBmC,CAAC,CAACnB,IAAF,GAAS,MAAMmB,CAAC,CAACnC,GAAF,GAAQmC,CAAC,CAACnB,IAAzB,CAX4B,CAWG;AACrD;AACA;;AAEA,QAAIsB,OAAO,GAAGH,CAAC,CAACnC,GAAF,KAAU,CAAV,GAAc,CAAd,GAAkB,CAAhC;AACAmC,IAAAA,CAAC,CAACvB,KAAF,CAAQ2B,KAAR,GAAgB,UAAUJ,CAAC,CAACnB,IAAZ,GAAmB,MAAnB,GAA4BsB,OAA5B,GAAsC,KAAtD;AACAH,IAAAA,CAAC,CAACvB,KAAF,CAAQE,MAAR,GAAiB,UAAUqB,CAAC,CAACvB,KAAF,CAAQE,MAAlB,GAA2B,UAA5C;AACAqB,IAAAA,CAAC,CAACvB,KAAF,CAAQ4B,OAAR,GAAkB,UAAUL,CAAC,CAACvB,KAAF,CAAQG,IAAlB,GAAyB,MAAzB,GAAkCuB,OAAlC,GAA4C,KAA9D;AACD;;AAED,SAAO9B,YAAP;AACD;;AAEDiC,MAAM,CAACtD,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = _default;\n\nvar _overlap = _interopRequireDefault(require(\"./overlap\"));\n\nfunction getMaxIdxDFS(node, maxIdx, visited) {\n  for (var i = 0; i < node.friends.length; ++i) {\n    if (visited.indexOf(node.friends[i]) > -1) continue;\n    maxIdx = maxIdx > node.friends[i].idx ? maxIdx : node.friends[i].idx; // TODO : trace it by not object but kinda index or something for performance\n\n    visited.push(node.friends[i]);\n    var newIdx = getMaxIdxDFS(node.friends[i], maxIdx, visited);\n    maxIdx = maxIdx > newIdx ? maxIdx : newIdx;\n  }\n\n  return maxIdx;\n}\n\nfunction _default(_ref) {\n  var events = _ref.events,\n      minimumStartDifference = _ref.minimumStartDifference,\n      slotMetrics = _ref.slotMetrics,\n      accessors = _ref.accessors;\n  var styledEvents = (0, _overlap.default)({\n    events: events,\n    minimumStartDifference: minimumStartDifference,\n    slotMetrics: slotMetrics,\n    accessors: accessors\n  });\n  styledEvents.sort(function (a, b) {\n    a = a.style;\n    b = b.style;\n    if (a.top !== b.top) return a.top > b.top ? 1 : -1;else return a.top + a.height < b.top + b.height ? 1 : -1;\n  });\n\n  for (var i = 0; i < styledEvents.length; ++i) {\n    styledEvents[i].friends = [];\n    delete styledEvents[i].style.left;\n    delete styledEvents[i].style.left;\n    delete styledEvents[i].idx;\n    delete styledEvents[i].size;\n  }\n\n  for (var _i = 0; _i < styledEvents.length - 1; ++_i) {\n    var se1 = styledEvents[_i];\n    var y1 = se1.style.top;\n    var y2 = se1.style.top + se1.style.height;\n\n    for (var j = _i + 1; j < styledEvents.length; ++j) {\n      var se2 = styledEvents[j];\n      var y3 = se2.style.top;\n      var y4 = se2.style.top + se2.style.height; // be friends when overlapped\n\n      if (y3 <= y1 && y1 < y4 || y1 <= y3 && y3 < y2) {\n        // TODO : hashmap would be effective for performance\n        se1.friends.push(se2);\n        se2.friends.push(se1);\n      }\n    }\n  }\n\n  for (var _i2 = 0; _i2 < styledEvents.length; ++_i2) {\n    var se = styledEvents[_i2];\n    var bitmap = [];\n\n    for (var _j = 0; _j < 100; ++_j) {\n      bitmap.push(1);\n    } // 1 means available\n\n\n    for (var _j2 = 0; _j2 < se.friends.length; ++_j2) {\n      if (se.friends[_j2].idx !== undefined) bitmap[se.friends[_j2].idx] = 0;\n    } // 0 means reserved\n\n\n    se.idx = bitmap.indexOf(1);\n  }\n\n  for (var _i3 = 0; _i3 < styledEvents.length; ++_i3) {\n    var size = 0;\n    if (styledEvents[_i3].size) continue;\n    var allFriends = [];\n    var maxIdx = getMaxIdxDFS(styledEvents[_i3], 0, allFriends);\n    size = 100 / (maxIdx + 1);\n    styledEvents[_i3].size = size;\n\n    for (var _j3 = 0; _j3 < allFriends.length; ++_j3) {\n      allFriends[_j3].size = size;\n    }\n  }\n\n  for (var _i4 = 0; _i4 < styledEvents.length; ++_i4) {\n    var e = styledEvents[_i4];\n    e.style.left = e.idx * e.size; // stretch to maximum\n\n    var _maxIdx = 0;\n\n    for (var _j4 = 0; _j4 < e.friends.length; ++_j4) {\n      var idx = e.friends[_j4];\n      _maxIdx = _maxIdx > idx ? _maxIdx : idx;\n    }\n\n    if (_maxIdx <= e.idx) e.size = 100 - e.idx * e.size; // padding between events\n    // for this feature, `width` is not percentage based unit anymore\n    // it will be used with calc()\n\n    var padding = e.idx === 0 ? 0 : 3;\n    e.style.width = \"calc(\" + e.size + \"% - \" + padding + \"px)\";\n    e.style.height = \"calc(\" + e.style.height + \"% - 2px)\";\n    e.style.xOffset = \"calc(\" + e.style.left + \"% + \" + padding + \"px)\";\n  }\n\n  return styledEvents;\n}\n\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}