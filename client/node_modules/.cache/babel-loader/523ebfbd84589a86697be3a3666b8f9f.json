{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.getSlotMetrics = getSlotMetrics;\n\nvar dates = _interopRequireWildcard(require(\"./dates\"));\n\nvar getDstOffset = function getDstOffset(start, end) {\n  return start.getTimezoneOffset() - end.getTimezoneOffset();\n};\n\nvar getKey = function getKey(min, max, step, slots) {\n  return \"\" + +dates.startOf(min, 'minutes') + (\"\" + +dates.startOf(max, 'minutes')) + (step + \"-\" + slots);\n};\n\nfunction getSlotMetrics(_ref) {\n  var start = _ref.min,\n      end = _ref.max,\n      step = _ref.step,\n      timeslots = _ref.timeslots;\n  var key = getKey(start, end, step, timeslots); // if the start is on a DST-changing day but *after* the moment of DST\n  // transition we need to add those extra minutes to our minutesFromMidnight\n\n  var daystart = dates.startOf(start, 'day');\n  var daystartdstoffset = getDstOffset(daystart, start);\n  var totalMin = 1 + dates.diff(start, end, 'minutes') + getDstOffset(start, end);\n  var minutesFromMidnight = dates.diff(daystart, start, 'minutes') + daystartdstoffset;\n  var numGroups = Math.ceil(totalMin / (step * timeslots));\n  var numSlots = numGroups * timeslots;\n  var groups = new Array(numGroups);\n  var slots = new Array(numSlots); // Each slot date is created from \"zero\", instead of adding `step` to\n  // the previous one, in order to avoid DST oddities\n\n  for (var grp = 0; grp < numGroups; grp++) {\n    groups[grp] = new Array(timeslots);\n\n    for (var slot = 0; slot < timeslots; slot++) {\n      var slotIdx = grp * timeslots + slot;\n      var minFromStart = slotIdx * step; // A date with total minutes calculated from the start of the day\n\n      slots[slotIdx] = groups[grp][slot] = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 0, minutesFromMidnight + minFromStart, 0, 0);\n    }\n  } // Necessary to be able to select up until the last timeslot in a day\n\n\n  var lastSlotMinFromStart = slots.length * step;\n  slots.push(new Date(start.getFullYear(), start.getMonth(), start.getDate(), 0, minutesFromMidnight + lastSlotMinFromStart, 0, 0));\n\n  function positionFromDate(date) {\n    var diff = dates.diff(start, date, 'minutes') + getDstOffset(start, date);\n    return Math.min(diff, totalMin);\n  }\n\n  return {\n    groups: groups,\n    update: function update(args) {\n      if (getKey(args) !== key) return getSlotMetrics(args);\n      return this;\n    },\n    dateIsInGroup: function dateIsInGroup(date, groupIndex) {\n      var nextGroup = groups[groupIndex + 1];\n      return dates.inRange(date, groups[groupIndex][0], nextGroup ? nextGroup[0] : end, 'minutes');\n    },\n    nextSlot: function nextSlot(slot) {\n      var next = slots[Math.min(slots.indexOf(slot) + 1, slots.length - 1)]; // in the case of the last slot we won't a long enough range so manually get it\n\n      if (next === slot) next = dates.add(slot, step, 'minutes');\n      return next;\n    },\n    closestSlotToPosition: function closestSlotToPosition(percent) {\n      var slot = Math.min(slots.length - 1, Math.max(0, Math.floor(percent * numSlots)));\n      return slots[slot];\n    },\n    closestSlotFromPoint: function closestSlotFromPoint(point, boundaryRect) {\n      var range = Math.abs(boundaryRect.top - boundaryRect.bottom);\n      return this.closestSlotToPosition((point.y - boundaryRect.top) / range);\n    },\n    closestSlotFromDate: function closestSlotFromDate(date, offset) {\n      if (offset === void 0) {\n        offset = 0;\n      }\n\n      if (dates.lt(date, start, 'minutes')) return slots[0];\n      var diffMins = dates.diff(start, date, 'minutes');\n      return slots[(diffMins - diffMins % step) / step + offset];\n    },\n    startsBeforeDay: function startsBeforeDay(date) {\n      return dates.lt(date, start, 'day');\n    },\n    startsAfterDay: function startsAfterDay(date) {\n      return dates.gt(date, end, 'day');\n    },\n    startsBefore: function startsBefore(date) {\n      return dates.lt(dates.merge(start, date), start, 'minutes');\n    },\n    startsAfter: function startsAfter(date) {\n      return dates.gt(dates.merge(end, date), end, 'minutes');\n    },\n    getRange: function getRange(rangeStart, rangeEnd, ignoreMin, ignoreMax) {\n      if (!ignoreMin) rangeStart = dates.min(end, dates.max(start, rangeStart));\n      if (!ignoreMax) rangeEnd = dates.min(end, dates.max(start, rangeEnd));\n      var rangeStartMin = positionFromDate(rangeStart);\n      var rangeEndMin = positionFromDate(rangeEnd);\n      var top = rangeEndMin - rangeStartMin < step && !dates.eq(end, rangeEnd) ? (rangeStartMin - step) / (step * numSlots) * 100 : rangeStartMin / (step * numSlots) * 100;\n      return {\n        top: top,\n        height: rangeEndMin / (step * numSlots) * 100 - top,\n        start: positionFromDate(rangeStart),\n        startDate: rangeStart,\n        end: positionFromDate(rangeEnd),\n        endDate: rangeEnd\n      };\n    },\n    getCurrentTimePosition: function getCurrentTimePosition(rangeStart) {\n      var rangeStartMin = positionFromDate(rangeStart);\n      var top = rangeStartMin / (step * numSlots) * 100;\n      return top;\n    }\n  };\n}","map":{"version":3,"sources":["/home/miles/Desktop/jes-sched/client/node_modules/react-big-calendar/lib/utils/TimeSlots.js"],"names":["_interopRequireWildcard","require","exports","__esModule","getSlotMetrics","dates","getDstOffset","start","end","getTimezoneOffset","getKey","min","max","step","slots","startOf","_ref","timeslots","key","daystart","daystartdstoffset","totalMin","diff","minutesFromMidnight","numGroups","Math","ceil","numSlots","groups","Array","grp","slot","slotIdx","minFromStart","Date","getFullYear","getMonth","getDate","lastSlotMinFromStart","length","push","positionFromDate","date","update","args","dateIsInGroup","groupIndex","nextGroup","inRange","nextSlot","next","indexOf","add","closestSlotToPosition","percent","floor","closestSlotFromPoint","point","boundaryRect","range","abs","top","bottom","y","closestSlotFromDate","offset","lt","diffMins","startsBeforeDay","startsAfterDay","gt","startsBefore","merge","startsAfter","getRange","rangeStart","rangeEnd","ignoreMin","ignoreMax","rangeStartMin","rangeEndMin","eq","height","startDate","endDate","getCurrentTimePosition"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.getSlotMetrics = getSlotMetrics;\n\nvar dates = _interopRequireWildcard(require(\"./dates\"));\n\nvar getDstOffset = function getDstOffset(start, end) {\n  return start.getTimezoneOffset() - end.getTimezoneOffset();\n};\n\nvar getKey = function getKey(min, max, step, slots) {\n  return \"\" + +dates.startOf(min, 'minutes') + (\"\" + +dates.startOf(max, 'minutes')) + (step + \"-\" + slots);\n};\n\nfunction getSlotMetrics(_ref) {\n  var start = _ref.min,\n      end = _ref.max,\n      step = _ref.step,\n      timeslots = _ref.timeslots;\n  var key = getKey(start, end, step, timeslots); // if the start is on a DST-changing day but *after* the moment of DST\n  // transition we need to add those extra minutes to our minutesFromMidnight\n\n  var daystart = dates.startOf(start, 'day');\n  var daystartdstoffset = getDstOffset(daystart, start);\n  var totalMin = 1 + dates.diff(start, end, 'minutes') + getDstOffset(start, end);\n  var minutesFromMidnight = dates.diff(daystart, start, 'minutes') + daystartdstoffset;\n  var numGroups = Math.ceil(totalMin / (step * timeslots));\n  var numSlots = numGroups * timeslots;\n  var groups = new Array(numGroups);\n  var slots = new Array(numSlots); // Each slot date is created from \"zero\", instead of adding `step` to\n  // the previous one, in order to avoid DST oddities\n\n  for (var grp = 0; grp < numGroups; grp++) {\n    groups[grp] = new Array(timeslots);\n\n    for (var slot = 0; slot < timeslots; slot++) {\n      var slotIdx = grp * timeslots + slot;\n      var minFromStart = slotIdx * step; // A date with total minutes calculated from the start of the day\n\n      slots[slotIdx] = groups[grp][slot] = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 0, minutesFromMidnight + minFromStart, 0, 0);\n    }\n  } // Necessary to be able to select up until the last timeslot in a day\n\n\n  var lastSlotMinFromStart = slots.length * step;\n  slots.push(new Date(start.getFullYear(), start.getMonth(), start.getDate(), 0, minutesFromMidnight + lastSlotMinFromStart, 0, 0));\n\n  function positionFromDate(date) {\n    var diff = dates.diff(start, date, 'minutes') + getDstOffset(start, date);\n    return Math.min(diff, totalMin);\n  }\n\n  return {\n    groups: groups,\n    update: function update(args) {\n      if (getKey(args) !== key) return getSlotMetrics(args);\n      return this;\n    },\n    dateIsInGroup: function dateIsInGroup(date, groupIndex) {\n      var nextGroup = groups[groupIndex + 1];\n      return dates.inRange(date, groups[groupIndex][0], nextGroup ? nextGroup[0] : end, 'minutes');\n    },\n    nextSlot: function nextSlot(slot) {\n      var next = slots[Math.min(slots.indexOf(slot) + 1, slots.length - 1)]; // in the case of the last slot we won't a long enough range so manually get it\n\n      if (next === slot) next = dates.add(slot, step, 'minutes');\n      return next;\n    },\n    closestSlotToPosition: function closestSlotToPosition(percent) {\n      var slot = Math.min(slots.length - 1, Math.max(0, Math.floor(percent * numSlots)));\n      return slots[slot];\n    },\n    closestSlotFromPoint: function closestSlotFromPoint(point, boundaryRect) {\n      var range = Math.abs(boundaryRect.top - boundaryRect.bottom);\n      return this.closestSlotToPosition((point.y - boundaryRect.top) / range);\n    },\n    closestSlotFromDate: function closestSlotFromDate(date, offset) {\n      if (offset === void 0) {\n        offset = 0;\n      }\n\n      if (dates.lt(date, start, 'minutes')) return slots[0];\n      var diffMins = dates.diff(start, date, 'minutes');\n      return slots[(diffMins - diffMins % step) / step + offset];\n    },\n    startsBeforeDay: function startsBeforeDay(date) {\n      return dates.lt(date, start, 'day');\n    },\n    startsAfterDay: function startsAfterDay(date) {\n      return dates.gt(date, end, 'day');\n    },\n    startsBefore: function startsBefore(date) {\n      return dates.lt(dates.merge(start, date), start, 'minutes');\n    },\n    startsAfter: function startsAfter(date) {\n      return dates.gt(dates.merge(end, date), end, 'minutes');\n    },\n    getRange: function getRange(rangeStart, rangeEnd, ignoreMin, ignoreMax) {\n      if (!ignoreMin) rangeStart = dates.min(end, dates.max(start, rangeStart));\n      if (!ignoreMax) rangeEnd = dates.min(end, dates.max(start, rangeEnd));\n      var rangeStartMin = positionFromDate(rangeStart);\n      var rangeEndMin = positionFromDate(rangeEnd);\n      var top = rangeEndMin - rangeStartMin < step && !dates.eq(end, rangeEnd) ? (rangeStartMin - step) / (step * numSlots) * 100 : rangeStartMin / (step * numSlots) * 100;\n      return {\n        top: top,\n        height: rangeEndMin / (step * numSlots) * 100 - top,\n        start: positionFromDate(rangeStart),\n        startDate: rangeStart,\n        end: positionFromDate(rangeEnd),\n        endDate: rangeEnd\n      };\n    },\n    getCurrentTimePosition: function getCurrentTimePosition(rangeStart) {\n      var rangeStartMin = positionFromDate(rangeStart);\n      var top = rangeStartMin / (step * numSlots) * 100;\n      return top;\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}